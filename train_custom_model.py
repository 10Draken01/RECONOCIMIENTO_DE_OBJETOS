"""
Script de entrenamiento para el dataset de Roboflow
Entrena el modelo de l√°piz usando el dataset ya etiquetado
"""

import os
import yaml
from ultralytics import YOLO
import torch
from pathlib import Path
import shutil
from datetime import datetime

def verify_roboflow_dataset():
    """Verificar que el dataset de Roboflow est√© completo"""
    print("üîç Verificando dataset de Roboflow...")
    
    dataset_path = Path("dataset_lapiz")
    
    # Verificar estructura
    required_dirs = [
        dataset_path / "train" / "images",
        dataset_path / "train" / "labels",
        dataset_path / "valid" / "images", 
        dataset_path / "valid" / "labels",
        dataset_path / "test" / "images",
        dataset_path / "test" / "labels"
    ]
    
    for dir_path in required_dirs:
        if not dir_path.exists():
            print(f"‚ùå Falta directorio: {dir_path}")
            return False
        
        file_count = len(list(dir_path.glob("*")))
        print(f"‚úÖ {dir_path.parent.name}/{dir_path.name}: {file_count} archivos")
    
    # Verificar data.yaml
    yaml_path = dataset_path / "data.yaml"
    if yaml_path.exists():
        print(f"‚úÖ Archivo data.yaml encontrado")
        
        # Leer contenido
        try:
            with open(yaml_path, 'r') as f:
                data_config = yaml.safe_load(f)
            
            print(f"üìä Dataset configuraci√≥n:")
            print(f"   ‚Ä¢ Clases: {data_config.get('nc', 'N/A')}")
            print(f"   ‚Ä¢ Nombres: {data_config.get('names', [])}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error leyendo data.yaml: {e}")
    else:
        print("‚ùå No se encontr√≥ data.yaml")
        return False
    
    return True

def validate_sample_labels():
    """Verificar algunas etiquetas para asegurar formato correcto"""
    print("üè∑Ô∏è Verificando formato de etiquetas...")
    
    dataset_path = Path("dataset_lapiz")
    
    # Verificar algunas etiquetas de train
    train_labels = list((dataset_path / "train" / "labels").glob("*.txt"))
    
    if not train_labels:
        print("‚ùå No se encontraron etiquetas en train")
        return False
    
    valid_labels = 0
    issues = []
    
    # Verificar primeras 5 etiquetas
    for label_file in train_labels[:5]:
        try:
            with open(label_file, 'r') as f:
                lines = f.readlines()
            
            for line_num, line in enumerate(lines, 1):
                line = line.strip()
                if not line:
                    continue
                
                parts = line.split()
                if len(parts) != 5:
                    issues.append(f"{label_file.name}:{line_num} - Formato incorrecto: {line}")
                    continue
                
                try:
                    class_id, x, y, w, h = map(float, parts)
                    
                    # Verificar rangos
                    if not (0 <= x <= 1 and 0 <= y <= 1 and 0 <= w <= 1 and 0 <= h <= 1):
                        issues.append(f"{label_file.name}:{line_num} - Coordenadas fuera de rango")
                    else:
                        valid_labels += 1
                        
                except ValueError:
                    issues.append(f"{label_file.name}:{line_num} - Valores no num√©ricos")
        
        except Exception as e:
            issues.append(f"{label_file.name} - Error leyendo archivo: {e}")
    
    if issues:
        print(f"‚ö†Ô∏è Encontrados {len(issues)} problemas:")
        for issue in issues[:3]:  # Mostrar solo los primeros 3
            print(f"   ‚Ä¢ {issue}")
        if len(issues) > 3:
            print(f"   ... y {len(issues) - 3} m√°s")
        
        if valid_labels == 0:
            print("‚ùå No se encontraron etiquetas v√°lidas")
            return False
    
    print(f"‚úÖ Etiquetas v√°lidas encontradas: {valid_labels}")
    return True

def train_lapiz_model():
    """Entrenar modelo de l√°piz con dataset de Roboflow"""
    print("üöÄ Iniciando entrenamiento del modelo de l√°piz...")
    
    dataset_path = Path("dataset_lapiz")
    yaml_path = dataset_path / "data.yaml"
    
    if not yaml_path.exists():
        print(f"‚ùå No se encontr√≥ {yaml_path}")
        return None
    
    # Cargar modelo base YOLOv8
    print("üì¶ Cargando modelo base YOLOv8n...")
    model = YOLO('yolov8n.pt')
    
    # Configuraci√≥n de entrenamiento
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    project_name = f"lapiz_roboflow_{timestamp}"
    
    print(f"üéØ Configuraci√≥n de entrenamiento:")
    print(f"   ‚Ä¢ Proyecto: {project_name}")
    print(f"   ‚Ä¢ Dataset: {yaml_path}")
    print(f"   ‚Ä¢ Modelo base: YOLOv8n")
    print(f"   ‚Ä¢ Epochs: 100")
    print(f"   ‚Ä¢ Batch size: 16")
    print(f"   ‚Ä¢ Image size: 640")
    print(f"   ‚Ä¢ Device: {'GPU' if torch.cuda.is_available() else 'CPU'}")
    print(f"   ‚Ä¢ Optimizaciones: Activadas")
    
    try:
        print("\nüèÉ‚Äç‚ôÇÔ∏è Iniciando entrenamiento...")
        print("‚è≥ Esto puede tomar 10-30 minutos dependiendo de tu hardware...")
        
        # Entrenar con configuraci√≥n optimizada
        results = model.train(
            data=str(yaml_path),
            epochs=100,               # Epochs suficientes
            batch=16,                 # Batch size est√°ndar
            imgsz=640,                # Tama√±o de imagen est√°ndar
            device='cpu' if not torch.cuda.is_available() else 0,
            project="models",
            name=project_name,
            
            # Par√°metros de control
            patience=25,              # Parar si no mejora en 25 epochs
            save_period=10,           # Guardar cada 10 epochs
            
            # Visualizaci√≥n
            verbose=True,
            plots=True,               # Generar gr√°ficas
            
            # Data Augmentation (optimizado para l√°pices)
            augment=True,
            mixup=0.1,                # Mezcla de im√°genes
            copy_paste=0.1,           # Copy-paste augmentation
            
            # Transformaciones geom√©tricas
            degrees=15,               # Rotaci√≥n ¬±15 grados
            translate=0.1,            # Translaci√≥n ¬±10%
            scale=0.5,                # Escala ¬±50%
            shear=5.0,                # Shear ¬±5 grados
            perspective=0.0,          # Sin perspectiva (mejor para objetos simples)
            
            # Flip augmentations
            flipud=0.5,               # Volteo vertical
            fliplr=0.5,               # Volteo horizontal
            
            # Mosaic y otras augmentations
            mosaic=1.0,               # Mosaic augmentation
            
            # Augmentaciones de color (suaves para l√°pices)
            hsv_h=0.015,              # Variaci√≥n de matiz
            hsv_s=0.7,                # Variaci√≥n de saturaci√≥n  
            hsv_v=0.4,                # Variaci√≥n de brillo
            
            # Optimizaci√≥n del entrenamiento
            lr0=0.01,                 # Learning rate inicial
            lrf=0.1,                  # Learning rate final
            momentum=0.937,           # Momentum
            weight_decay=0.0005,      # Weight decay
            warmup_epochs=3,          # Epochs de calentamiento
            warmup_momentum=0.8,      # Momentum inicial
            warmup_bias_lr=0.1,       # Learning rate inicial para bias
            
            # Configuraciones adicionales
            box=7.5,                  # Box loss weight
            cls=0.5,                  # Classification loss weight
            dfl=1.5,                  # DFL loss weight
            
            # Validaci√≥n
            val=True,                 # Validar durante entrenamiento
            save_json=True,           # Guardar resultados en JSON
            
            # Workspace
            exist_ok=True,            # Permitir sobrescribir
            pretrained=True,          # Usar pesos preentrenados
            optimize=False,           # No optimizar para inferencia a√∫n
            keras=False,              # No usar Keras
            resume=False,             # No resumir entrenamiento
            
            # Configuraci√≥n de workers
            workers=8,                # N√∫mero de workers para carga de datos
            
            # Configuraci√≥n de memoria
            close_mosaic=10           # Desactivar mosaic en √∫ltimos N epochs
        )
        
        # Verificar resultados
        best_model_path = Path("models") / project_name / "weights" / "best.pt"
        last_model_path = Path("models") / project_name / "weights" / "last.pt"
        
        if best_model_path.exists():
            # Copiar modelo a ubicaci√≥n final
            final_model_path = Path("models") / "lapiz_detector.pt"
            shutil.copy2(best_model_path, final_model_path)
            
            print(f"\nüéâ ¬°ENTRENAMIENTO COMPLETADO!")
            print(f"‚úÖ Mejor modelo guardado en: {final_model_path}")
            
            # Mostrar estad√≠sticas finales
            print(f"\nüìä ESTAD√çSTICAS DEL ENTRENAMIENTO:")
            print(f"   ‚Ä¢ Directorio completo: models/{project_name}")
            print(f"   ‚Ä¢ Mejor modelo: {best_model_path}")
            print(f"   ‚Ä¢ √öltimo modelo: {last_model_path}")
            print(f"   ‚Ä¢ Gr√°ficas de entrenamiento: models/{project_name}/results.png")
            print(f"   ‚Ä¢ M√©tricas de validaci√≥n: models/{project_name}/results.csv")
            
            # Probar el modelo con una imagen de test
            test_model_performance(final_model_path, dataset_path)
            
            return str(final_model_path)
            
        else:
            print("\n‚ùå No se encontr√≥ el modelo entrenado")
            print(f"üí° Revisa la carpeta: models/{project_name}")
            return None
            
    except Exception as e:
        print(f"\n‚ùå Error durante entrenamiento: {e}")
        import traceback
        traceback.print_exc()
        return None

def test_model_performance(model_path, dataset_path):
    """Probar el modelo con im√°genes de test"""
    print(f"\nüß™ Probando modelo entrenado...")
    
    try:
        # Cargar modelo entrenado
        model = YOLO(str(model_path))
        
        # Buscar im√°genes de test
        test_images_dir = dataset_path / "test" / "images"
        test_images = list(test_images_dir.glob("*.jpg"))
        
        if test_images:
            print(f"üñºÔ∏è Probando con {len(test_images)} im√°genes de test...")
            
            total_detections = 0
            successful_images = 0
            
            for i, test_img in enumerate(test_images[:3]):  # Probar solo 3 im√°genes
                try:
                    # Ejecutar predicci√≥n
                    results = model(str(test_img), conf=0.5)
                    
                    if results and len(results) > 0:
                        detections = len(results[0].boxes) if results[0].boxes else 0
                        total_detections += detections
                        
                        if detections > 0:
                            successful_images += 1
                            print(f"   ‚úÖ {test_img.name}: {detections} l√°pices detectados")
                            
                            # Guardar imagen con predicciones
                            annotated = results[0].plot()
                            import cv2
                            output_path = Path("models") / f"test_prediction_{i+1}.jpg"
                            cv2.imwrite(str(output_path), annotated)
                            
                        else:
                            print(f"   ‚ö†Ô∏è {test_img.name}: Sin detecciones")
                    else:
                        print(f"   ‚ùå {test_img.name}: Error en predicci√≥n")
                        
                except Exception as e:
                    print(f"   ‚ùå {test_img.name}: Error - {e}")
            
            # Resumen de pruebas
            print(f"\nüìä RESUMEN DE PRUEBAS:")
            print(f"   ‚Ä¢ Im√°genes probadas: {min(3, len(test_images))}")
            print(f"   ‚Ä¢ Im√°genes con detecciones: {successful_images}")
            print(f"   ‚Ä¢ Total de detecciones: {total_detections}")
            print(f"   ‚Ä¢ Promedio por imagen: {total_detections/min(3, len(test_images)):.1f}")
            
            if successful_images > 0:
                print(f"   ‚úÖ El modelo parece estar funcionando correctamente")
            else:
                print(f"   ‚ö†Ô∏è El modelo no detect√≥ l√°pices en las im√°genes de prueba")
                print(f"   üí° Esto puede ser normal si las im√°genes son muy diferentes")
                
        else:
            print("‚ö†Ô∏è No se encontraron im√°genes de test")
            
    except Exception as e:
        print(f"‚ùå Error probando modelo: {e}")

def check_system_requirements():
    """Verificar requisitos del sistema"""
    print("üîç Verificando requisitos del sistema...")
    
    try:
        import ultralytics
        print(f"‚úÖ Ultralytics: {ultralytics.__version__}")
    except ImportError:
        print("‚ùå Ultralytics no encontrado. Instala: pip install ultralytics")
        return False
    
    try:
        import torch
        print(f"‚úÖ PyTorch: {torch.__version__}")
        print(f"‚úÖ CUDA disponible: {torch.cuda.is_available()}")
        if torch.cuda.is_available():
            print(f"   ‚Ä¢ GPU: {torch.cuda.get_device_name(0)}")
            print(f"   ‚Ä¢ Memoria GPU: {torch.cuda.get_device_properties(0).total_memory / 1e9:.1f} GB")
    except ImportError:
        print("‚ùå PyTorch no encontrado")
        return False
    
    try:
        import cv2
        print(f"‚úÖ OpenCV: {cv2.__version__}")
    except ImportError:
        print("‚ùå OpenCV no encontrado")
        return False
    
    return True

def main():
    """Funci√≥n principal"""
    print("üöÄ ENTRENADOR DE MODELO CON DATASET DE ROBOFLOW")
    print("="*60)
    print("üéØ Tu dataset est√° perfectamente organizado!")
    print("üìä Train: 39 im√°genes | Valid: 11 im√°genes | Test: 6 im√°genes")
    print("="*60)
    
    # Verificar requisitos
    if not check_system_requirements():
        print("\n‚ùå Faltan requisitos del sistema")
        return
    
    # Verificar dataset
    if not verify_roboflow_dataset():
        print("\n‚ùå Problemas con el dataset")
        return
    
    # Verificar etiquetas
    if not validate_sample_labels():
        print("\n‚ùå Problemas con las etiquetas")
        return
    
    # Confirmar entrenamiento
    print(f"\nüéØ ¬øIniciar entrenamiento del modelo de l√°piz?")
    print(f"‚è≥ Tiempo estimado: 15-30 minutos")
    print(f"üíæ Espacio necesario: ~500MB")
    
    try:
        choice = input("\n¬øContinuar? (s/n): ").lower().strip()
        
        if choice in ['s', 'si', 's√≠', 'y', 'yes']:
            print(f"\nüöÄ ¬°Iniciando entrenamiento!")
            
            model_path = train_lapiz_model()
            
            if model_path:
                print(f"\nüéä ¬°√âXITO TOTAL!")
                print(f"="*60)
                print(f"‚úÖ Modelo entrenado exitosamente")
                print(f"üì¶ Ubicaci√≥n: {model_path}")
                print(f"üéØ Listo para usar en la aplicaci√≥n")
                
                print(f"\nüöÄ PR√ìXIMOS PASOS:")
                print(f"1. Ejecuta: python yolo_detector_escritura.py")
                print(f"2. Carga el modelo: {model_path}")
                print(f"3. ¬°Prueba detectando l√°pices y libros!")
                
                print(f"\nüí° RECORDATORIO:")
                print(f"‚Ä¢ El modelo detecta L√ÅPICES (personalizado)")
                print(f"‚Ä¢ YOLOv8 detecta LIBROS (preentrenado)")
                print(f"‚Ä¢ Cuando est√°n JUNTOS = KIT DE ESCRITURA")
                
            else:
                print(f"\n‚ùå Entrenamiento fall√≥")
                print(f"üí° Revisa los errores anteriores")
                
        else:
            print(f"üëã Entrenamiento cancelado")
            
    except KeyboardInterrupt:
        print(f"\n‚ö†Ô∏è Entrenamiento cancelado por el usuario")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")

if __name__ == "__main__":
    main()